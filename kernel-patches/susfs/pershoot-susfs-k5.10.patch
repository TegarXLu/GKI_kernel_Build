commit 0e1d95826a5ddc3284b450ebdb4333cdc4a12ee1
Author: pershoot <28478728-pershoot@users.noreply.gitlab.com>
Date:   Sun Jan 18 15:48:50 2026 -0500

    fs: Introduce helper for uname spoof coexistence with toolkit (susfs)

diff --git a/fs/susfs.c b/fs/susfs.c
index dfd48ab09b32..cc79738547fa 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -587,10 +587,46 @@ void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
 static DEFINE_SPINLOCK(susfs_spin_lock_set_uname);
 static struct st_susfs_uname my_uname;
+static bool susfs_uname_owner; // true = spoof on (non-default)
 static void susfs_my_uname_init(void) {
 	memset(&my_uname, 0, sizeof(my_uname));
 }
 
+// Return if susfs owns (non-default)
+bool susfs_uname_is_active(void)
+{
+	return susfs_uname_owner;
+}
+EXPORT_SYMBOL_GPL(susfs_uname_is_active);
+
+// Updates spoof buffer (called from supercalls (determine ownership))
+int susfs_set_uname_from_kernel(const char *release, const char *version)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&susfs_spin_lock_set_uname, flags);
+
+	if (!release || !release[0]) {
+		strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
+	} else {
+		strncpy(my_uname.release, release, __NEW_UTS_LEN);
+	}
+
+	if (!version || !version[0]) {
+		strncpy(my_uname.version, utsname()->version, __NEW_UTS_LEN);
+	} else {
+		strncpy(my_uname.version, version, __NEW_UTS_LEN);
+	}
+
+	spin_unlock_irqrestore(&susfs_spin_lock_set_uname, flags);
+
+	SUSFS_LOGI("kernel-set spoofed release: '%s', version: '%s'\n",
+			my_uname.release, my_uname.version);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(susfs_set_uname_from_kernel);
+
 void susfs_set_uname(void __user **user_info) {
 	struct st_susfs_uname info = {0};
 
@@ -600,16 +636,27 @@ void susfs_set_uname(void __user **user_info) {
 	}
 
 	spin_lock(&susfs_spin_lock_set_uname);
-	if (!strcmp(info.release, "default")) {
-		strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
-	} else {
-		strncpy(my_uname.release, info.release, __NEW_UTS_LEN);
-	}
-	if (!strcmp(info.version, "default")) {
-		strncpy(my_uname.version, utsname()->version, __NEW_UTS_LEN);
+
+	// SuSFS spoof off (default/default); clear buffer and release ownership
+	if (!strcmp(info.release, "default") && !strcmp(info.version, "default")) {
+		susfs_my_uname_init();
+		susfs_uname_owner = false;
 	} else {
-		strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
+		// SuSFS spoof on; owns, update buffer
+		susfs_uname_owner = true;
+		// disregard toolkit
+
+		if (!strcmp(info.release, "default"))
+			strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
+		else
+			strncpy(my_uname.release, info.release, __NEW_UTS_LEN);
+
+		if (!strcmp(info.version, "default"))
+			strncpy(my_uname.version, utsname()->version, __NEW_UTS_LEN);
+		else
+			strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
 	}
+
 	spin_unlock(&susfs_spin_lock_set_uname);
 	SUSFS_LOGI("setting spoofed release: '%s', version: '%s'\n",
 				my_uname.release, my_uname.version);

commit 8960e20ceb9b377d4f6572c66c6645b106e06516
Author: pershoot <28478728-pershoot@users.noreply.gitlab.com>
Date:   Mon Jan 5 22:01:51 2026 -0500

    fs: Allow susfs core to be built with no features

diff --git a/fs/susfs.c b/fs/susfs.c
index db459b4b8c9c..dfd48ab09b32 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -869,7 +869,7 @@ void susfs_set_avc_log_spoofing(void __user **user_info) {
 }
 
 /* get susfs enabled features */
-static int copy_config_to_buf(const char *config_string, char *buf_ptr, size_t *copied_size, size_t bufsize) {
+static __maybe_unused int copy_config_to_buf(const char *config_string, char *buf_ptr, size_t *copied_size, size_t bufsize) {
 	size_t tmp_size = strlen(config_string);
 
 	*copied_size += tmp_size;
@@ -884,7 +884,7 @@ static int copy_config_to_buf(const char *config_string, char *buf_ptr, size_t *
 void susfs_get_enabled_features(void __user **user_info) {
 	struct st_susfs_enabled_features *info = (struct st_susfs_enabled_features *)kzalloc(sizeof(struct st_susfs_enabled_features), GFP_KERNEL);
 	char *buf_ptr = NULL;
-	size_t copied_size = 0;
+	__maybe_unused size_t copied_size = 0;
 
 	if (!info) {
 		info->err = -ENOMEM;

commit 0a2c268d9cb4e97eb04db6f19fb6f39bc155b597
Author: pershoot <28478728-pershoot@users.noreply.gitlab.com>
Date:   Sun Jan 4 10:10:20 2026 -0500

    fs: Add safe teardown for KSU AVC spoof (susfs)
    
    -To be used with:
     'kernel: Promote AVC spoof as a core KSU feature'
     (https://github.com/pershoot/KernelSU-Next)

diff --git a/fs/susfs.c b/fs/susfs.c
index a49807488f6b..db459b4b8c9c 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -839,9 +839,11 @@ void susfs_add_sus_map(void __user **user_info) {
 /* susfs avc log spoofing */
 static DEFINE_SPINLOCK(susfs_spin_lock_set_avc_log_spoofing);
 extern bool susfs_is_avc_log_spoofing_enabled;
+extern void ksu_avc_spoof_susfs_on(void);
 
 void susfs_set_avc_log_spoofing(void __user **user_info) {
 	struct st_susfs_avc_log_spoofing info = {0};
+	int old_enabled;
 
 	if (copy_from_user(&info, (struct st_susfs_avc_log_spoofing __user*)*user_info, sizeof(info))) {
 		info.err = -EFAULT;
@@ -849,8 +851,14 @@ void susfs_set_avc_log_spoofing(void __user **user_info) {
 	}
 
 	spin_lock(&susfs_spin_lock_set_avc_log_spoofing);
+	old_enabled = susfs_is_avc_log_spoofing_enabled;
 	susfs_is_avc_log_spoofing_enabled = info.enabled;
 	spin_unlock(&susfs_spin_lock_set_avc_log_spoofing);
+
+	if (info.enabled && !old_enabled) {
+		ksu_avc_spoof_susfs_on();
+	}
+
 	SUSFS_LOGI("susfs_is_avc_log_spoofing_enabled: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
