diff --git a/fs/read_write.c b/fs/read_write.c
index 0000000..1111111 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -1,3 +1,13 @@
+/* KernelSU manual hook support */
+#if defined(CONFIG_KSU) && defined(CONFIG_KSU_MANUAL_HOOK)
+extern int ksu_handle_sys_read(unsigned int fd, char __user *buf, size_t count);
+extern int ksu_handle_sys_write(unsigned int fd, const char __user *buf, size_t count);
+#endif
+
+
+
 SYSCALL_DEFINE3(lseek, unsigned int, fd, off_t, offset, unsigned int, whence)
 {
 	return ksys_lseek(fd, offset, whence);
@@ -190,8 +200,22 @@ ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)
 	return ret;
 }
 
 SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
 {
+#if defined(CONFIG_KSU) && defined(CONFIG_KSU_MANUAL_HOOK)
+	/*
+	 * If KernelSU wants to handle this syscall, return its result.
+	 * Return value convention:
+	 *   <0  : error
+	 *   >=0 : handled and return directly
+	 */
+	int ksu_ret = ksu_handle_sys_read(fd, buf, count);
+	if (ksu_ret >= 0)
+		return ksu_ret;
+#endif
 	return ksys_read(fd, buf, count);
 }
 
@@ -232,8 +256,22 @@ ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)
 	return ret;
 }
 
 SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
 		size_t, count)
 {
+#if defined(CONFIG_KSU) && defined(CONFIG_KSU_MANUAL_HOOK)
+	/*
+	 * If KernelSU wants to handle this syscall, return its result.
+	 * Return value convention:
+	 *   <0  : error
+	 *   >=0 : handled and return directly
+	 */
+	int ksu_ret = ksu_handle_sys_write(fd, buf, count);
+	if (ksu_ret >= 0)
+		return ksu_ret;
+#endif
 	return ksys_write(fd, buf, count);
 }
diff --git a/kernel/reboot.c b/kernel/reboot.c
index 0000000..2222222 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -1,3 +1,10 @@
+/* KernelSU manual hook support */
+#if defined(CONFIG_KSU) && defined(CONFIG_KSU_MANUAL_HOOK)
+extern int ksu_handle_sys_reboot(int magic1, int magic2, unsigned int cmd,
+				void __user *arg);
+#endif
+
 SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 		void __user *, arg)
 {
@@ -7,6 +14,20 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 	char buffer[256];
 	int ret = 0;
 
+#if defined(CONFIG_KSU) && defined(CONFIG_KSU_MANUAL_HOOK)
+	/*
+	 * KernelSU manual hook for reboot.
+	 * If it returns >= 0, syscall is handled and we return directly.
+	 */
+	int ksu_ret = ksu_handle_sys_reboot(magic1, magic2, cmd, arg);
+	if (ksu_ret >= 0)
+		return ksu_ret;
+#endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))
 		return -EPERM;
